# azure-pipelines.yml
# Azure DevOps Pipeline para sincroniza√ß√£o de artigos do Intercom
# Executa automaticamente diariamente √†s 2:00 UTC

trigger: none  # N√£o executa em push - apenas no schedule

pr: none  # N√£o executa em pull requests

# ‚è∞ AGENDAMENTO AUTOM√ÅTICO
schedules:
  # # A cada 2 horas (hor√°rio UTC)
  # - cron: '0 */2 * * *'
  #   displayName: 'Sync a cada 2 horas'
  #   branches:
  #     include:
  #       - main
  #       - master
  #   always: true  # Executa mesmo sem mudan√ßas no c√≥digo

  # Sincroniza√ß√£o completa di√°ria √†s 2:00 UTC
  - cron: '0 2 * * *'
    displayName: 'Sync di√°rio completo √†s 2:00 UTC'
    branches:
      include:
        - main
        - master
    always: true

  # # Sincroniza√ß√£o adicional √†s 14:00 UTC (opcional)
  # - cron: '0 14 * * *'
  #   displayName: 'Sync adicional √†s 14:00 UTC'
  #   branches:
  #     include:
  #       - main
  #       - master
  #   always: true

# üéØ POOL DE AGENTES
pool:
  vmImage: 'ubuntu-latest'  # Pode usar windows-latest se preferir

# üìã VARI√ÅVEIS DO PIPELINE
variables:
  - name: pythonVersion
    value: '3.11'
  - name: workingDirectory
    value: '$(System.DefaultWorkingDirectory)'

# üöÄ JOBS
jobs:
  - job: IntercomSync
    displayName: 'Sincroniza√ß√£o Artigos Intercom ‚Üí MongoDB'
    timeoutInMinutes: 60  # Timeout de 1 hora
    
    # üì¶ STEPS
    steps:
      # 1. Checkout do c√≥digo
      - checkout: self
        displayName: 'üì• Checkout do reposit√≥rio'
        clean: true

      # 2. Setup Python
      - task: UsePythonVersion@0
        displayName: 'üêç Setup Python $(pythonVersion)'
        inputs:
          versionSpec: '$(pythonVersion)'

      # 3. Cache das depend√™ncias Python
      - task: Cache@2
        displayName: 'üì¶ Cache depend√™ncias Python'
        inputs:
          key: 'python | "$(Agent.OS)" | requirements.txt'
          restoreKeys: |
            python | "$(Agent.OS)"
            python
          path: ~/.cache/pip

      # 4. Instala depend√™ncias
      - script: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
        displayName: 'üìö Instalar depend√™ncias'
        workingDirectory: '$(workingDirectory)'

      # 5. Verifica√ß√£o de sa√∫de das APIs
      - script: |
          python -c "
          import os
          from src.api.intercom_client import IntercomClient
          from src.mongodb.mongodb_client import MongoDBClient
          
          print('üîç Testando conex√µes...')
          
          # Testa Intercom
          try:
              client = IntercomClient()
              if client.test_connection():
                  print('‚úÖ Intercom API: OK')
              else:
                  print('‚ùå Intercom API: FALHOU')
                  exit(1)
          except Exception as e:
              print(f'‚ùå Erro Intercom: {e}')
              exit(1)
          
          # Testa MongoDB
          try:
              mongo = MongoDBClient()
              mongo.connect()
              print('‚úÖ MongoDB: OK')
              mongo.close_connection()
          except Exception as e:
              print(f'‚ùå Erro MongoDB: {e}')
              exit(1)
              
          print('‚úÖ Todas as conex√µes OK!')
          "
        displayName: 'üîç Verificar conex√µes API'
        workingDirectory: '$(workingDirectory)'
        env:
          OPENAI_API_KEY: $(OPENAI_API_KEY)
          INTERCOM_API_TOKEN: $(INTERCOM_API_TOKEN)
          INTERCOM_BASE_URL: $(INTERCOM_BASE_URL)
          MONGODB_CONNECTION_STRING: $(MONGODB_CONNECTION_STRING)
          DATABASE_NAME: $(DATABASE_NAME)
          COLLECTION_NAME: $(COLLECTION_NAME)

      # 6. Execu√ß√£o principal da sincroniza√ß√£o
      - script: |
          echo "üîÑ Iniciando sincroniza√ß√£o de artigos..."
          echo "üìÖ Hor√°rio: $(date)"
          echo "üîñ Trigger: $(Build.CronSchedule.DisplayName)"
          echo "üåø Branch: $(Build.SourceBranch)"
          echo ""
          
          # Executa o pipeline principal
          python run_intercom_pipeline.py
          
          echo ""
          echo "‚úÖ Sincroniza√ß√£o conclu√≠da em $(date)"
        displayName: 'üîÑ Executar sincroniza√ß√£o'
        workingDirectory: '$(workingDirectory)'
        env:
          OPENAI_API_KEY: $(OPENAI_API_KEY)
          INTERCOM_API_TOKEN: $(INTERCOM_API_TOKEN)
          INTERCOM_BASE_URL: $(INTERCOM_BASE_URL)
          MONGODB_CONNECTION_STRING: $(MONGODB_CONNECTION_STRING)
          DATABASE_NAME: $(DATABASE_NAME)
          COLLECTION_NAME: $(COLLECTION_NAME)
          EMBEDDING_MODEL: $(EMBEDDING_MODEL)
          RAG_SYNTH_MODEL: $(RAG_SYNTH_MODEL)
          RAG_IMAGE_PROCESSOR_MODEL: $(RAG_IMAGE_PROCESSOR_MODEL)
          RAG_CONTEXTUAL_ENRICHER_MODEL: $(RAG_CONTEXTUAL_ENRICHER_MODEL)
          RAG_CHUNKER_MODEL: $(RAG_CHUNKER_MODEL)
          RAG_CATEGORIZER_MODEL: $(RAG_CATEGORIZER_MODEL)
          EMBEDDING_DIMENSIONS: $(EMBEDDING_DIMENSIONS)
          MAX_CHUNK_SIZE: $(MAX_CHUNK_SIZE)

      # 7. Coleta de m√©tricas p√≥s-execu√ß√£o
      - script: |
          python -c "
          import json
          from datetime import datetime
          from src.mongodb.mongodb_client import MongoDBClient
          
          print('üìä Coletando m√©tricas p√≥s-sincroniza√ß√£o...')
          
          try:
              mongo = MongoDBClient()
              collection = mongo.connect()
              
              # Conta documentos por idioma
              pipeline = [
                  {'\\$group': {
                      '_id': '\\$language',
                      'count': {'\\$sum': 1},
                      'last_update': {'\\$max': '\\$meta_data.last_worker_sync'}
                  }},
                  {'\\$sort': {'count': -1}}
              ]
              
              results = list(collection.aggregate(pipeline))
              
              print('üìà Resumo da base de conhecimento:')
              total = 0
              for result in results:
                  lang = result['_id'] or 'unknown'
                  count = result['count']
                  total += count
                  print(f'   ‚Ä¢ {lang.upper()}: {count:,} documentos')
              
              print(f'   ‚Ä¢ TOTAL: {total:,} documentos')
              print('üìÖ Sincroniza√ß√£o executada com sucesso!')
              
              mongo.close_connection()
              
          except Exception as e:
              print(f'‚ö†Ô∏è Erro ao coletar m√©tricas: {e}')
          "
        displayName: 'üìä M√©tricas finais'
        workingDirectory: '$(workingDirectory)'
        env:
          MONGODB_CONNECTION_STRING: $(MONGODB_CONNECTION_STRING)
          DATABASE_NAME: $(DATABASE_NAME)
          COLLECTION_NAME: $(COLLECTION_NAME)
        condition: always()  # Sempre executa, mesmo se o step anterior falhar

      # 8. Cleanup (opcional)
      - script: |
          echo "üßπ Limpando arquivos tempor√°rios..."
          # Remove logs antigos, cache, etc.
        displayName: 'üßπ Cleanup'
        condition: always()

  # üö® JOB CONDICIONAL: Notifica√ß√£o em caso de falha
  - job: NotifyFailure
    displayName: 'Notificar falha via Teams/Slack'
    dependsOn: IntercomSync
    condition: failed()
    
    steps:
      # Notifica√ß√£o via webhook (Teams, Slack, etc.)
      - script: |
          curl -X POST "$(TEAMS_WEBHOOK_URL)" \
            -H "Content-Type: application/json" \
            -d '{
              "text": "üö® FALHA na sincroniza√ß√£o de artigos do Intercom",
              "summary": "Pipeline $(Build.BuildNumber) falhou",
              "sections": [{
                "facts": [
                  {"name": "Pipeline", "value": "$(Build.DefinitionName)"},
                  {"name": "Build", "value": "$(Build.BuildNumber)"},
                  {"name": "Branch", "value": "$(Build.SourceBranch)"},
                  {"name": "Trigger", "value": "$(Build.CronSchedule.DisplayName)"},
                  {"name": "Hor√°rio", "value": "'$(date)'"}
                ]
              }]
            }'
        displayName: 'üîî Notificar falha'
        condition: and(failed(), ne(variables['TEAMS_WEBHOOK_URL'], ''))

# üéØ JOBS OPCIONAIS PARA DIFERENTES CEN√ÅRIOS

  # Job para sincroniza√ß√£o manual com par√¢metros
  - job: ManualSync
    displayName: 'Sincroniza√ß√£o Manual (apenas quando disparado manualmente)'
    condition: eq(variables['Build.Reason'], 'Manual')
    
    steps:
      - checkout: self
      
      - task: UsePythonVersion@0
        inputs:
          versionSpec: '3.11'
      
      - script: pip install -r requirements.txt
        displayName: 'Instalar depend√™ncias'
      
      - script: |
          echo "üîß SINCRONIZA√á√ÉO MANUAL"
          echo "Par√¢metros personalizados podem ser adicionados aqui..."
          python run_intercom_pipeline.py --manual
        displayName: 'Execu√ß√£o manual'
        env:
          OPENAI_API_KEY: $(OPENAI_API_KEY)
          INTERCOM_API_TOKEN: $(INTERCOM_API_TOKEN)
          MONGODB_CONNECTION_STRING: $(MONGODB_CONNECTION_STRING)

  # Job para valida√ß√£o de qualidade dos dados
  - job: DataQuality
    displayName: 'Valida√ß√£o qualidade dos dados'
    dependsOn: IntercomSync
    condition: succeeded()
    
    steps:
      - checkout: self
      
      - task: UsePythonVersion@0
        inputs:
          versionSpec: '3.11'
      
      - script: pip install -r requirements.txt
        displayName: 'Instalar depend√™ncias'
      
      - script: |
          python -c "
          from src.mongodb.mongodb_client import MongoDBClient
          import statistics
          
          print('üîç Validando qualidade dos dados...')
          
          mongo = MongoDBClient()
          collection = mongo.connect()
          
          # Verifica documentos sem embedding
          no_embedding = collection.count_documents({
              'embedding': {'\\$exists': False}
          })
          
          # Verifica documentos com conte√∫do muito curto
          short_content = collection.count_documents({
              'content': {'\\$regex': '^.{0,50}$'}
          })
          
          # Estat√≠sticas de tamanho de conte√∫do
          docs = list(collection.find({}, {'content': 1}).limit(1000))
          sizes = [len(doc.get('content', '')) for doc in docs]
          
          if sizes:
              avg_size = statistics.mean(sizes)
              print(f'üìè Tamanho m√©dio do conte√∫do: {avg_size:.0f} chars')
              print(f'üìä Min: {min(sizes)}, Max: {max(sizes)}')
          
          print(f'‚ö†Ô∏è Documentos sem embedding: {no_embedding}')
          print(f'‚ö†Ô∏è Documentos com conte√∫do muito curto: {short_content}')
          
          # Falha se muitos problemas
          if no_embedding > 10 or short_content > 50:
              print('‚ùå QUALIDADE DOS DADOS ABAIXO DO ESPERADO!')
              exit(1)
          else:
              print('‚úÖ Qualidade dos dados OK')
          
          mongo.close_connection()
          "
        displayName: 'Verificar qualidade'
        env:
          MONGODB_CONNECTION_STRING: $(MONGODB_CONNECTION_STRING)
          DATABASE_NAME: $(DATABASE_NAME)
          COLLECTION_NAME: $(COLLECTION_NAME)